<html>
	<head>
		<title>Operational Transform</title>
		<script type="text/javascript" src="node_modules/object.observe/dist/object-observe.js" charset="utf-8"></script>
		<script type="text/javascript" src="node_modules/array.observe/array-observe.js" charset="utf-8"></script>
		<script type="text/javascript" src="./js/libs/jquery.js" charset="utf-8"></script>
		<script type="text/javascript" src="./build/bundle.js" charset="utf-8"></script>

		<link rel="stylesheet" href="./style.css"></link>

		<style>
			*,
			*::before,
			*::after {
			    -webkit-box-sizing: border-box;
			       -moz-box-sizing: border-box;
			            box-sizing: border-box;
			}
			.code {
			  font-family:Monaco, Bitstream Vera Sans Mono, Lucida Console, Terminal;
				font-size: 0.84em;
				padding-left: 0.1em;
				padding-right: 0.1em;
			}
			.explanation {
				padding: 8px;
			}
			.demo {
				background-color: #f5f5f5;
				padding: 16px;
				font-size: 1rem;
				width: 100%;
			}
			textarea {
				font-size: 0.8em;
			}
			input[type=number] {
				width: 5em;
			}
			#computers {
		    display: -webkit-flex;
		    display: flex;

				-webkit-flex-direction: row;
				flex-direction: row;
				-webkit-flex-wrap: wrap;
				flex-wrap: wrap;
			}
			#computers > * + * {
				margin-right: 8px;
			}
			#computers > :first-child {
				margin-right: 8px;
			}
			.computer {
  			-webkit-flex: 1;
        flex: 1;

				-webkit-flex-grow: 1;
				flex-grow: 1;

				min-width: 180px;
				margin-bottom: 0.4em;
			}
			.computer div {
				font-size: 0.8em;
			}
			.computer h4 {
				margin-top: 0.4em;
				margin-bottom: 0.2em;
			}
			.computer > textarea {
				width: 100%;
			}
			.computer > * + * {
				margin-top: 2px;
			}
			.demo button {
				cursor: pointer;
				font-size: 0.8em;
				background-color: #fdfdfd;
				border-color: #fff #fff #f0f0f0 #f0f0f0;
				border-width: 2px;
			}
			.demo button#add-client {
			}
			.demo button#add-client:hover {
				background-color: #fff;
			}
		</style>
	</head>

	<body>
		<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />

		<div class="wrapper wide">
      <header id="header">
        <h1>Kenrick Rilee</h1>
        <a href="/">Projects</a><br/>
				<br/>
				<a href="/files/kenrick-rilee-resume-2016.pdf">Resume</a><br/>
				<a href="https://github.com/cricklet">GitHub</a><br/>
				<br/>
      </header>
			<section class="wide">
				<div class="top">
					<h1>Collaborative Editing via OT (<a href="https://github.com/cricklet/blue-ot.js">GitHub</a>)</h1>
				</div>

				<br/>
				<div class="demo">
					<div id="computers">
						<div class="computer"></div>
						<div class="computer"></div>
						<div class="computer"></div>
					</div>
					<button id="add-client">Add Client</button>
				</div>

				<br/>
				<br/>
				<div class="explanation">
					<h4>TLDR</h4>

					<p>
						Implementing realtime collaborative editing with operational transforms (OT) was fun.
						However, the difficulty of the solution is pushing me towards learning
						about alternate solutions like CRDTs and WOOT.
					</p>
					<p>
						I'm excited about applying realtime collaboration to domains <i>other</i> than
						text, so the relative complexity of OT is a serious detractor.
					</p>

					<br/>
					<h2>Why operational transforms?</h2>

					<p>
						Operational transform (OT) is one of the core technologies enabling
						realtime collaborative text editing in Google Docs. It is the most
						well-known and implemented solution for realtime collaboration.
					</p>

					<p>
						In addition to enabling smooth real-time interaction, OT makes it possible
						for apps to seamlessly operate in high-latency or even offline situations.
						Actions that a user takes while the app is offline
						can be optimistically applied and later synchronized
						with the server -- all with the guarantee of eventual consistency.
					</p>

					<p>
						Perhaps the most exciting benefit is the fact that OT is essentially
						a version control system. Continuous integration and tools like
						<span class="code">git</span> have revolutionized the software
						industry. Realtime collaborative systems can bring those
						same kinds of benefits to other domains.
					</p>

					<p>
						For a deep description of how operational transforms work, check out
						<a href="http://www.codecommit.com/blog/java/understanding-and-applying-operational-transformation">Daniel Spiewak's description</a>
						of the algorithm.
					</p>

					<br/>
					<h2>Difficulties</h2>

					<p>
						<div style="padding-left: 3em; padding-right: 3em">
							"Unfortunately,	implementing OT sucks. The algorithms are really hard and time
							consuming to implement correctly.
							Wave took 2 years to write and if we rewrote it today,
							it would take almost as long to write a second time."
							<br/>
							<div style="text-align: right">Joseph Gentle, a developer on Google Wave</div>
						</div>
					</p>

					<p>
						While OT isn't prohibitively difficult to implement for
						a simple text system
						it can get complicated fast: you have to model your domain
						in terms of operations (i.e. insert or delete) and
						describe in very precise terms how each kind of operation
						affects related operations.	Implementation is further
						complicated by the fact that ordering matters so much.
					</p>

					<p>
						Other algorithms like
						<a href="https://en.wikipedia.org/wiki/Conflict-free_replicated_data_type">Conflict Free Replicated Data Type</a> (CRDT)
						and <a href="https://hal.inria.fr/inria-00071240/document">WithOut Operational Transform</a> (WOOT)
						aim to alleviate these complications while retaining the overall benefit
						of collaborative realtime systems. CRDTs
						rely on operations which are necessarily commutative, dramatically
						simplifying the ordering of operations.
						Another method involves using a
						<a href="http://marijnhaverbeke.nl/blog/collaborative-editing.html">position map</a>
						to describe how the positions in a document are shifted between states.
					</p>

					<br/>
					<h2>Implementation</h2>

					<h3><a href="https://github.com/cricklet/blue-ot.js/blob/master/js/ot/text_operations.js">js/ot/text_operations.js</a></h3>

					<p>
						In OT, a document is represented as a series of operations
						(i.e. insert text here, delete text there).
					</p>

					<p>
						When conflicting operations arise, each operation is transformed in a
						method similar to <span class="code">git merge</span>: a new operation
						is created which can be applied directly to a client's state without
						that client needing to change its history.
					</p>

					<p>
						In my implementation (and in most practical implementations), the algorithm
						is centralized: the server dictates which operations should take precedence
						during a conflict. While OT intends to be a distributed algorithm, it is
						much easier to implement/understand when centralized.
					</p>

					<br/>
					<h3><a href="https://github.com/cricklet/blue-ot.js/blob/master/js/ot/orchestrator.js">js/ot/orchestrator.js</a></h3>

					<p>
						The most complicated part of the algorithm (and the most difficult
						part to test) is the orchestration of the clients and servers.
						When a client and a server have multiple operations out of sync,
						how are the operations transmitted &amp; and how are they applied?
					</p>

					<p>
						Part of the difficulty is that the client and server
						do not have full knowledge of each other. It would be too
						costly for the server to track the history and state of each
						individual client.
					</p>

					<p>
						In addition, each client/server has a different history of operations.
						Because OT acts like a <span class="code">git merge</span> rather
						than a <span class="code">git rebase</span>, operation
						histories are never re-written and thus can diverge wildly.
					</p>

					<p>
						In a hand-wavey way, the client only sends its operations
						to the server after it has finished synchronizing with
						the server's state. This allows the server to be relatively dumb
						and moves most computation onto the clients.
					</p>

					<p>
						For a more complete explanation,
						<a href="http://www.codecommit.com/blog/java/understanding-and-applying-operational-transformation">
							Daniel Spedwak's write-up is fantastic
						</a>.
					</p>


					<br/>
					<br/>
					<br/>
					<br/>
					<br/>
					<br/>

					<p>
						PS: I'm looking for a new job! I like collaborative systems,
						(typed) Javascript, interaction/UI, and graphics. Check out
						<a href="http://cricklet.github.io/">my portfolio</a>
						and send me an email if you're hiring! (kenrick dot rilee at gmail)
					</p>


				</div>
			</section>
		</div>
	</body>
</html>
