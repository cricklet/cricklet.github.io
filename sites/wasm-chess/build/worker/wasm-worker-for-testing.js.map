{
  "version": 3,
  "sources": ["../../../src/worker/worker-types.ts", "../../../src/worker/wasm-worker-for-testing.ts"],
  "sourcesContent": ["\nexport type SendToWorker = {\n    name: 'counter-go',\n} | {\n    name: 'perft-setup',\n    fen: string,\n    depth: number,\n} | SendToWorkerWithResponse;\n\nexport type SendToWorkerWithResponse = ({\n    name: 'counter-count',\n} | {\n    name: 'perft-count',\n} | {\n    name: 'uci',\n    line: string,\n} | {\n    name: 'uci-flush-output',\n}) & { id: number };\n\nexport function encodeSendToWorker(msg: SendToWorker): string {\n    return JSON.stringify(msg);\n}\n\nexport function decodeSendToWorker(msg: string): SendToWorker {\n    return JSON.parse(msg);\n}\n\nexport type ReceiveFromWorkerMessage = ({\n    name: 'ready',\n} | {\n    name: 'log',\n    msg: Array<any>,\n} | {\n    name: 'error',\n    msg: string,\n}) & {\n    kind: 'message',\n};\n\nexport type ReceiveFromWorker = ReceiveFromWorkerMessage | ReceiveFromWorkerResponse;\n\nexport type ReceiveFromWorkerResponse = ({\n    name: 'counter-count',\n    counterResult: number,\n} | {\n    name: 'perft-count',\n    perftResult: number,\n} | {\n    name: 'uci',\n    output: string,\n} | {\n    name: 'uci-flush-output',\n    output: string,\n}) & {\n    kind: 'response',\n    id: number,\n};\n\nexport function isEmpty(msg: ReceiveFromWorker): boolean {\n    if (msg.name === 'log') {\n        return msg.msg.length === 0;\n    } else if (msg.name === 'uci') {\n        return msg.output.length === 0;\n    } else if (msg.name === 'uci-flush-output') {\n        return msg.output.length === 0;\n    }\n    return false\n}\n\nexport function isResponse(msg: ReceiveFromWorker): msg is ReceiveFromWorkerResponse {\n    return msg.kind === 'response' && msg.id !== undefined;\n}\n\nexport function responseMatchesRequest<\n    S extends SendToWorkerWithResponse,\n    R extends ReceiveFromWorkerResponse & Pick<S, \"name\">\n>(msg: SendToWorkerWithResponse, response: ReceiveFromWorker): response is R {\n    return isResponse(response) && response.id === msg.id && response.name === msg.name;\n}\n\nexport function encodeReceiveFromWorker(msg: ReceiveFromWorker): string {\n    return JSON.stringify(msg);\n}\n\nexport function decodeReceiveFromWorker(msg: string): ReceiveFromWorker {\n    return JSON.parse(msg);\n}\n", "import { ReceiveFromWorker, ReceiveFromWorkerMessage, decodeSendToWorker, encodeReceiveFromWorker } from \"./worker-types\";\n\nimportScripts('../../lib/wasm-pack/wasm_chess.js');\n\nfunction send(msg: ReceiveFromWorker) {\n    self.postMessage(encodeReceiveFromWorker(msg));\n}\n\n\nglobalThis.BindingsJs = {\n    log_to_js: function (msg) {\n        send({ kind: 'message', name: 'log', msg: [msg] });\n    }\n};\n\nasync function setupCounterForJs(): Promise<{handleEvent: (MessageEvent: any) => boolean}> {\n    let counterForJs = await wasm_bindgen.CounterForJs.new();\n    let counterThinkLoop: ReturnType<typeof setInterval> | undefined = undefined;\n\n    // handle messages passed to the worker\n    return {\n        handleEvent: (e: MessageEvent) => {\n            let data = decodeSendToWorker(e.data);\n\n            switch (data.name) {\n                case 'counter-go':\n                    counterThinkLoop = setInterval(() => {\n                        counterForJs.think();\n                    }); \n                    return true;\n                case 'counter-count':\n                    clearInterval(counterThinkLoop);\n                    send({ kind: 'message', name: 'log', msg: ['perft done'] });\n\n                    let counterResult = counterForJs.count();\n                    send({ kind: 'response', name: 'counter-count', id: data.id, counterResult });\n                    return true;\n\n                default:\n                    return false;\n            }\n        }\n    }\n}\n\nasync function setupPerftForJs(): Promise<{handleEvent: (MessageEvent: any) => boolean}> {\n    let perftForJs = await wasm_bindgen.PerftForJs.new();\n    let perftThinkLoop: ReturnType<typeof setInterval> | undefined = undefined;\n\n    // handle messages passed to the worker\n    return {\n        handleEvent: (e: MessageEvent) => {\n            let data = decodeSendToWorker(e.data);\n\n            switch (data.name) {\n                case 'perft-setup':\n                    perftForJs.setup(data.fen, data.depth);\n                    perftThinkLoop = setInterval(() => {\n                        send({ kind: 'message', name: 'log', msg: ['perft thinking'] });\n                        let done = perftForJs.think_and_return_done();\n                        if (done) {\n                            send({ kind: 'message', name: 'log', msg: ['perft finished naturally'] });\n                            clearInterval(perftThinkLoop);\n                        }\n                    }); \n                    return true;\n                case 'perft-count':\n                    clearInterval(perftThinkLoop);\n    \n                    let perftResult = perftForJs.count();\n                    send({ kind: 'response', name: 'perft-count', id: data.id, perftResult });\n                    return true;\n    \n                default:\n                    return false;\n            }\n        }\n    }\n}\n\n\nasync function init_wasm_in_worker() {\n    // load the wasm\n    await wasm_bindgen('../../lib/wasm-pack/wasm_chess_bg.wasm');\n\n    let counter = await setupCounterForJs();\n    let perft = await setupPerftForJs();\n\n    // handle messages passed to the worker\n    self.onmessage = async e => {\n        let data = decodeSendToWorker(e.data);\n\n        if (counter.handleEvent(e)) {\n            return;\n        }\n\n        if (perft.handleEvent(e)) {\n            return;\n        }\n\n        send({ kind: 'message', name: 'error', msg: `unknown message: ${data}` });\n    };\n\n    send({ kind: 'message', name: 'ready' });\n};\n\ninit_wasm_in_worker();"],
  "mappings": ";AAwBO,SAAS,mBAAmB,KAA2B;AAC1D,SAAO,KAAK,MAAM,GAAG;AACzB;AAuDO,SAAS,wBAAwB,KAAgC;AACpE,SAAO,KAAK,UAAU,GAAG;AAC7B;;;ACjFA,cAAc,mCAAmC;AAEjD,SAAS,KAAK,KAAwB;AAClC,OAAK,YAAY,wBAAwB,GAAG,CAAC;AACjD;AAGA,WAAW,aAAa;AAAA,EACpB,WAAW,SAAU,KAAK;AACtB,SAAK,EAAE,MAAM,WAAW,MAAM,OAAO,KAAK,CAAC,GAAG,EAAE,CAAC;AAAA,EACrD;AACJ;AAEA,eAAe,oBAA4E;AACvF,MAAI,eAAe,MAAM,aAAa,aAAa,IAAI;AACvD,MAAI,mBAA+D;AAGnE,SAAO;AAAA,IACH,aAAa,CAAC,MAAoB;AAC9B,UAAI,OAAO,mBAAmB,EAAE,IAAI;AAEpC,cAAQ,KAAK,MAAM;AAAA,QACf,KAAK;AACD,6BAAmB,YAAY,MAAM;AACjC,yBAAa,MAAM;AAAA,UACvB,CAAC;AACD,iBAAO;AAAA,QACX,KAAK;AACD,wBAAc,gBAAgB;AAC9B,eAAK,EAAE,MAAM,WAAW,MAAM,OAAO,KAAK,CAAC,YAAY,EAAE,CAAC;AAE1D,cAAI,gBAAgB,aAAa,MAAM;AACvC,eAAK,EAAE,MAAM,YAAY,MAAM,iBAAiB,IAAI,KAAK,IAAI,cAAc,CAAC;AAC5E,iBAAO;AAAA,QAEX;AACI,iBAAO;AAAA,MACf;AAAA,IACJ;AAAA,EACJ;AACJ;AAEA,eAAe,kBAA0E;AACrF,MAAI,aAAa,MAAM,aAAa,WAAW,IAAI;AACnD,MAAI,iBAA6D;AAGjE,SAAO;AAAA,IACH,aAAa,CAAC,MAAoB;AAC9B,UAAI,OAAO,mBAAmB,EAAE,IAAI;AAEpC,cAAQ,KAAK,MAAM;AAAA,QACf,KAAK;AACD,qBAAW,MAAM,KAAK,KAAK,KAAK,KAAK;AACrC,2BAAiB,YAAY,MAAM;AAC/B,iBAAK,EAAE,MAAM,WAAW,MAAM,OAAO,KAAK,CAAC,gBAAgB,EAAE,CAAC;AAC9D,gBAAI,OAAO,WAAW,sBAAsB;AAC5C,gBAAI,MAAM;AACN,mBAAK,EAAE,MAAM,WAAW,MAAM,OAAO,KAAK,CAAC,0BAA0B,EAAE,CAAC;AACxE,4BAAc,cAAc;AAAA,YAChC;AAAA,UACJ,CAAC;AACD,iBAAO;AAAA,QACX,KAAK;AACD,wBAAc,cAAc;AAE5B,cAAI,cAAc,WAAW,MAAM;AACnC,eAAK,EAAE,MAAM,YAAY,MAAM,eAAe,IAAI,KAAK,IAAI,YAAY,CAAC;AACxE,iBAAO;AAAA,QAEX;AACI,iBAAO;AAAA,MACf;AAAA,IACJ;AAAA,EACJ;AACJ;AAGA,eAAe,sBAAsB;AAEjC,QAAM,aAAa,wCAAwC;AAE3D,MAAI,UAAU,MAAM,kBAAkB;AACtC,MAAI,QAAQ,MAAM,gBAAgB;AAGlC,OAAK,YAAY,OAAM,MAAK;AACxB,QAAI,OAAO,mBAAmB,EAAE,IAAI;AAEpC,QAAI,QAAQ,YAAY,CAAC,GAAG;AACxB;AAAA,IACJ;AAEA,QAAI,MAAM,YAAY,CAAC,GAAG;AACtB;AAAA,IACJ;AAEA,SAAK,EAAE,MAAM,WAAW,MAAM,SAAS,KAAK,oBAAoB,IAAI,GAAG,CAAC;AAAA,EAC5E;AAEA,OAAK,EAAE,MAAM,WAAW,MAAM,QAAQ,CAAC;AAC3C;AAEA,oBAAoB;",
  "names": []
}
